<#@ template language="C#" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="CodeCharm.Entity.AuditFramework" #>

<# 
SchemaDataSet schemaDataSet = _params.SchemaDataSet;
SchemaDataSet.SchemaPrimaryKeysDataTable primaryKeysTable = schemaDataSet.SchemaPrimaryKeys;
EnumerableRowCollection<SchemaDataSet.SchemaPrimaryKeysRow> primaryKeysRows = primaryKeysTable.AsEnumerable();
var primaryKeysQuery = from primaryKeysRow in primaryKeysRows
                       where primaryKeysRow.TABLE_SCHEMA.Equals(_schema, StringComparison.OrdinalIgnoreCase)
                       where primaryKeysRow.TABLE_NAME.Equals(_auditedTable, StringComparison.OrdinalIgnoreCase)
                       select primaryKeysRow;
#>
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[<#= _params.AuditingSchema #>].[Trackº<#= _schema #>º<#= _auditedTable #>]') AND type IN (N'P', N'PC'))
    DROP PROCEDURE [<#= _params.AuditingSchema #>].[Trackº<#= _schema #>º<#= _auditedTable #>];
GO

CREATE PROCEDURE [<#= _params.AuditingSchema #>].[Trackº<#= _schema #>º<#= _auditedTable #>]
  @AuditºTransactionSequence   BIGINT
, @AuditºTransactionDepth      INT
, @AuditºAction                CHAR(1)
, @TrackºId                    BIGINT       OUTPUT
, @AuditºTimeStampUtc          DATETIME     OUTPUT
, @AuditºDesignatedUserId      SYSNAME

<# foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
{   #>
, @<#= primaryKeysRow.COLUMN_NAME #> <#= SchemaHelper.DataTypeWithDetail(primaryKeysRow, schemaDataSet.Columns) #>
<# 
}   #>
AS
BEGIN
/*
    READ THIS BEFORE EDITING THIS CODE
    ----------------------------------
    This code was automatically generated by the
    CodeCharm.Model.AuditFramework
    project.
    
    If you modify this code, and then execute 
    the AuditFramework tool, your modifications
    will be ignored and overwritten.
    
    Template: CreateTrackingInsertProcedure.tt
*/

    SET NOCOUNT ON;
        
    DECLARE @Error INT;

	BEGIN TRY
	    BEGIN TRANSACTION;
	    SAVE TRANSACTION <#= _schema #>º<#= _auditedTable #>;

	    DECLARE @AuditºTransactionSequenceInt       [BIGINT];
	    DECLARE @AuditºIsLocalTransactionSequence   [BIT];
	    
	    SET @AuditºTransactionSequenceInt = ISNULL(@AuditºTransactionSequence, 0);
	    SET @AuditºIsLocalTransactionSequence = ~ CONVERT(BIT, @AuditºTransactionSequenceInt);
		
	    IF @AuditºIsLocalTransactionSequence <> 0
	    BEGIN
	        EXECUTE [<#= _params.AuditingSchema #>].[RequestTransactionSequence] 
	              NULL
	            , @AuditºTransactionSequence OUTPUT
	            , @AuditºTransactionDepth OUTPUT;
	    END;

		-- Create the audit record first to get the TrackId value

	    SET @AuditºTimeStampUtc = ISNULL(@AuditºTimeStampUtc, GETUTCDATE());
	    
	    INSERT INTO [<#= _params.AuditingSchema #>].[AuditMaster]
	    (
	      [ServerId]
	    , [TransactionSequence]
	    , [TransactionDepth]
	    , [Action]
	    , [AuditedTableName]
	    , [TrackTableVersionName]
	    , [TimestampUtc]
	    , [ConnectionUserId]
	    , [DesignatedUserId]
	    , [PriorTrackºId]
	    )
	    VALUES
	    (
	      CONVERT(SYSNAME, SERVERPROPERTY('ServerName'))
	    , @AuditºTransactionSequence
	    , @AuditºTransactionDepth
	    , @AuditºAction
	    , '[<#= _schema #>].[<#= _auditedTable #>]'
	    , '<#= _trackingTableName #>' -- Tracking Table Name
	    , @AuditºTimestampUtc
	    , SYSTEM_USER
	    , @AuditºDesignatedUserId
	    , NULL
	    );

	    SET @TrackºId = SCOPE_IDENTITY();

		-- Record the changes in the Tracking table

	    IF @AuditºAction = 'D'
	    BEGIN
	        INSERT INTO [<#= _params.AuditingSchema #>].[<#= _trackingTableName #>]
	            (
	              [TrackºId]
	<# foreach(SchemaDataSet.ColumnsRow columnsRow in _targetTableColumns)
	{   #>
	            , [<#= columnsRow.COLUMN_NAME #>]
	<# 
	}   #>
	            )
	            VALUES
	            (
	              @TrackºId
	<# 
	PushIndent("            ");
	foreach(SchemaDataSet.ColumnsRow columnsRow in _targetTableColumns)
	{   
	     SchemaDataSet.ColumnsRow row = columnsRow;
	     if (primaryKeysQuery.Any(primaryKeysRow => primaryKeysRow.COLUMN_NAME.Equals(row.COLUMN_NAME, StringComparison.OrdinalIgnoreCase)))
	    { 
	        WriteLine(", @" + row.COLUMN_NAME);
	    }
	    else
	    {
	        WriteLine(", NULL");
	    }
	}   
	PopIndent();
	#>
	            );
	    END
	    ELSE
	    BEGIN
	        INSERT INTO [<#= _params.AuditingSchema #>].[<#= _trackingTableName #>]
	            (
	              [TrackºId]
	<# foreach(SchemaDataSet.ColumnsRow columnsRow in _targetTableColumns)
	{   #>
	            , [<#= columnsRow.COLUMN_NAME #>]
	<# 
	}   #>
	            )
	            SELECT  
	                      @TrackºId
	<# foreach(SchemaDataSet.ColumnsRow columnsRow in _targetTableColumns)
	{   #>
	                    , [<#= columnsRow.COLUMN_NAME #>]
	<# 
	}   #>
	                FROM    [<#= _schema #>].[<#= _auditedTable #>]
	                WHERE
	-- primary key values match arguments
	<# 
	PushIndent("                    ");
	bool first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{
	    if (!first)
	    { 
	        Write("AND ");
	    }
	    else
	    {
	        Write("    ");
	    }
	    WriteLine("[{0}] = @{0}", primaryKeysRow.COLUMN_NAME);
	    first = false;
	}   
	PopIndent();
	#>					;
				
	    END;
	    
	    IF @AuditºIsLocalTransactionSequence <> 0
	    BEGIN
	        EXECUTE [<#= _params.AuditingSchema #>].[ReleaseTransactionSequence] 
	              @AuditºTransactionSequence
	            , @AuditºTransactionDepth;
	    END

	    COMMIT TRANSACTION;
	END TRY
	BEGIN CATCH
	    DECLARE	  @ErrorMessage    NVARCHAR(4000)
			  	, @ErrorNumber     INT
				, @ErrorSeverity   INT
				, @ErrorState      INT
				, @ErrorLine       INT
				, @ErrorProcedure  NVARCHAR(200);

	    -- Assign variables to error-handling functions that 
	    -- capture information for RAISERROR.
	    SELECT	  @ErrorNumber = ERROR_NUMBER()
				, @ErrorSeverity = ERROR_SEVERITY()
				, @ErrorState = ERROR_STATE()
				, @ErrorLine = ERROR_LINE()
				, @ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-');

		IF XACT_STATE() = -1 -- uncommittable
		BEGIN
			ROLLBACK TRANSACTION <#= _schema #>º<#= _auditedTable #>;
		END;
		
		IF XACT_STATE() = 1 -- committable
		BEGIN
			COMMIT TRANSACTION;
		END;
		
	    -- Build the message string that will contain original
	    -- error information.
	    SELECT @ErrorMessage = N'Error %d, Level %d, State %d, Procedure %s, Line %d, Message: '+ ERROR_MESSAGE();
		
		IF @ErrorState = 0
			SET @ErrorState = 1;

	    -- Raise an error: msg_str parameter of RAISERROR will contain
	    -- the original error information.
	    RAISERROR 
	        (
	          @ErrorMessage 
	        , @ErrorSeverity 
	        , 1               
	        , @ErrorNumber    	-- parameter: original error number.
	        , @ErrorSeverity  	-- parameter: original error severity.
	        , @ErrorState     	-- parameter: original error state.
	        , @ErrorProcedure 	-- parameter: original error procedure name.
	        , @ErrorLine       	-- parameter: original error line number.
	        );
	END CATCH
    
END
GO
