<#@ template language="C#" #>

IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[<#= _params.AuditingSchema #>].[BuildDelta]') AND type IN (N'P', N'PC'))
    DROP PROCEDURE [<#= _params.AuditingSchema #>].[BuildDelta]
GO

CREATE PROCEDURE [<#= _params.AuditingSchema #>].[BuildDelta]
AS

/*
    READ THIS BEFORE EDITING THIS CODE
    ----------------------------------
    This code was automatically generated by the
    CodeCharm.Model.AuditFramework
    project.
    
    If you modify this code, and then execute 
    the AuditFramework tool, your modifications
    will be ignored and overwritten.
    
    Template: CreateBuildDeltaProcedure.tt
    
    REMARKS
    -------
    This procedure is meant to be executed sparsely.
    It walks through the AuditMaster table, looking for Tracked
    records that have not had a corresponding Delta record built 
    to show which fields have changed. When it finds a record
    without a Delta record, it calls the Delta* procedure
    to create the Delta record.
    
    The time to call this stored procedure is when you want
    to make sure the AuditMaster, Track, and Delta tables reflect
    all recent changes. It is important to call it just before
    attempting to retrieve records, but it is not necessary to 
    call this procedure before every single attempt if those attempts
    occur rapidly.
    
    As a maintenance note, it is very important that the BuildDelta
    procedure is executed prior to performing DDL that changes the
    schema (followed by a new execution of the AuditFramework tool).
    The Delta* procedures compare prior versions of the tracking tables
    against only the current schema version (as of the time the 
    AuditFramework tool is run). The results of running BuildDelta on 
    records which have not been checked prior to updating the schema 
    is not predictable, and is not expected to work.
*/
	SET NOCOUNT ON;

	BEGIN TRY
	    BEGIN TRANSACTION;
	    SAVE TRANSACTION <#= _params.AuditingSchema #>ºBuildDelta;

	    DECLARE @TrackId [BIGINT];
	    DECLARE @TrackingTableName [SYSNAME];
	    DECLARE @DeltaProcedureSql [NVARCHAR](max);

	    DECLARE masterCursor CURSOR LOCAL
	        FAST_FORWARD
	        FOR SELECT    [AuditMaster].[TrackºId]
	                    , [AuditMaster].[TrackTableVersionName]
	                FROM    [<#= _params.AuditingSchema #>].[AuditMaster]
	                    INNER JOIN  [<#= _params.AuditingSchema #>].[Catalog]
	                            ON  [Catalog].[AuditingTableName] = [AuditMaster].[TrackTableVersionName]
	                WHERE   [AuditMaster].[PriorTrackºId] IS NULL
	                    AND [Catalog].[Archived] = 0
	                ORDER BY  [AuditMaster].[TransactionSequence]
	                        , [AuditMaster].[TimestampUtc]
	                        , [AuditMaster].[TrackºId];

	    OPEN masterCursor;

	    FETCH NEXT FROM masterCursor
	        INTO    @TrackId, @TrackingTableName;

	    WHILE @@FETCH_STATUS = 0
	    BEGIN

	        SET @DeltaProcedureSql = '[<#= _params.AuditingSchema #>].[Deltaº' + @TrackingTableName + ']';
	        
	        EXECUTE @DeltaProcedureSql @TrackId;

	        FETCH NEXT FROM masterCursor
	            INTO    @TrackId, @TrackingTableName;
	    END;

	    CLOSE   masterCursor;
	    DEALLOCATE  masterCursor;

	    COMMIT TRANSACTION;
	END TRY
	BEGIN CATCH
	    DECLARE	  @ErrorMessage    NVARCHAR(4000)
			  	, @ErrorNumber     INT
				, @ErrorSeverity   INT
				, @ErrorState      INT
				, @ErrorLine       INT
				, @ErrorProcedure  NVARCHAR(200);

	    -- Assign variables to error-handling functions that 
	    -- capture information for RAISERROR.
	    SELECT	  @ErrorNumber = ERROR_NUMBER()
				, @ErrorSeverity = ERROR_SEVERITY()
				, @ErrorState = ERROR_STATE()
				, @ErrorLine = ERROR_LINE()
				, @ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-');

		IF XACT_STATE() = -1 -- uncommittable
		BEGIN
			ROLLBACK TRANSACTION <#= _params.AuditingSchema #>ºBuildDelta;
		END;
		
		IF XACT_STATE() = 1 -- committable
		BEGIN
			COMMIT TRANSACTION;
		END;
		
	    -- Build the message string that will contain original
	    -- error information.
	    SELECT @ErrorMessage = N'Error %d, Level %d, State %d, Procedure %s, Line %d, Message: '+ ERROR_MESSAGE();
		
		IF @ErrorState = 0
			SET @ErrorState = 1;

	    -- Raise an error: msg_str parameter of RAISERROR will contain
	    -- the original error information.
	    RAISERROR 
	        (
	          @ErrorMessage 
	        , @ErrorSeverity 
	        , 1               
	        , @ErrorNumber    	-- parameter: original error number.
	        , @ErrorSeverity  	-- parameter: original error severity.
	        , @ErrorState     	-- parameter: original error state.
	        , @ErrorProcedure 	-- parameter: original error procedure name.
	        , @ErrorLine       	-- parameter: original error line number.
	        );

	END CATCH;

GO