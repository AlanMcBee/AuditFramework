<#@ template language="C#" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="CodeCharm.Entity.AuditFramework" #>

<# 
SchemaDataSet schemaDataSet = _params.SchemaDataSet;
SchemaDataSet.SchemaPrimaryKeysDataTable primaryKeysTable = schemaDataSet.SchemaPrimaryKeys;
EnumerableRowCollection<SchemaDataSet.SchemaPrimaryKeysRow> primaryKeysRows = primaryKeysTable.AsEnumerable();
var primaryKeysQuery = from primaryKeysRow in primaryKeysRows
                       where primaryKeysRow.TABLE_SCHEMA.Equals(_schema, StringComparison.OrdinalIgnoreCase)
                       where primaryKeysRow.TABLE_NAME.Equals(_tableName, StringComparison.OrdinalIgnoreCase)
                       select primaryKeysRow;
bool first = true;
#>
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[<#= _schema #>].[<#= _params.AuditingSchema #>º<#= _tableName #>]'))
    DROP TRIGGER [<#= _schema #>].[<#= _params.AuditingSchema #>º<#= _tableName #>];
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[<#= _schema #>].[<#= _params.AuditingSchema #>º<#= _tableName #>ºInsert]'))
    DROP TRIGGER [<#= _schema #>].[<#= _params.AuditingSchema #>º<#= _tableName #>ºInsert];
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[<#= _schema #>].[<#= _params.AuditingSchema #>º<#= _tableName #>ºUpdate]'))
    DROP TRIGGER [<#= _schema #>].[<#= _params.AuditingSchema #>º<#= _tableName #>ºUpdate];
IF  EXISTS (SELECT * FROM sys.triggers WHERE object_id = OBJECT_ID(N'[<#= _schema #>].[<#= _params.AuditingSchema #>º<#= _tableName #>ºDelete]'))
    DROP TRIGGER [<#= _schema #>].[<#= _params.AuditingSchema #>º<#= _tableName #>ºDelete];
GO

CREATE TRIGGER [<#= _schema #>].[<#= _params.AuditingSchema #>º<#= _tableName #>]
   ON  [<#= _schema #>].[<#= _tableName #>] 
   AFTER INSERT, UPDATE, DELETE
AS 
BEGIN
/*
    READ THIS BEFORE EDITING THIS CODE
    ----------------------------------
    This code was automatically generated by the
    CodeCharm.Model.AuditFramework
    project.
    
    If you modify this code, and then execute 
    the AuditFramework tool, your modifications
    will be ignored and overwritten.
    
    Template: CreateTrigger.tt
*/
    SET NOCOUNT ON;

	BEGIN TRY
	    DECLARE @TrackºId                           [BIGINT];
	    DECLARE @AuditºTimeStampUtc                 [DATETIME];
	    DECLARE @AuditºTransactionSequence          [BIGINT];
	    DECLARE @AuditºTransactionDepth             [INT];
	    DECLARE @AuditºAction                       [NCHAR](1);
	    DECLARE @AuditºDesignatedUserId             [SYSNAME];
	    DECLARE @AuditºTransactionLastUpdatedUtc    [DATETIME];
	    DECLARE @AuditºIsLocalTransactionSequence   [BIT];
	    DECLARE @AuditºTransactionSequenceInt       [BIGINT];
	    
	    EXECUTE [<#= _params.AuditingSchema #>].CurrentTransactionSequence 
	          @AuditºTransactionSequence OUTPUT
	        , @AuditºTransactionDepth OUTPUT
	        , @AuditºDesignatedUserId OUTPUT
	        , @AuditºTransactionLastUpdatedUtc OUTPUT;

	    SET @AuditºTransactionSequenceInt = ISNULL(@AuditºTransactionSequence, 0);
	    SET @AuditºIsLocalTransactionSequence = ~ CONVERT(BIT, @AuditºTransactionSequenceInt);
		
	    IF @AuditºIsLocalTransactionSequence <> 0
	    BEGIN
	        EXECUTE [<#= _params.AuditingSchema #>].[RequestTransactionSequence] 
	              NULL
	            , @AuditºTransactionSequence OUTPUT
	            , @AuditºTransactionDepth OUTPUT;
	    END;

	<# 
	string insertedTableName = _schema + "º" + _tableName + "ºInserted";
	string deletedTableName = _schema + "º" + _tableName + "ºDeleted";
	#>
	    SELECT
	<# 
	first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	            <# Write(first ? "  " : ", ");#>[<#= primaryKeysRow.COLUMN_NAME #>]
	<# 
	    first = false;
	}   #>
	        INTO #<#= insertedTableName #> 
	        FROM [inserted];
	    
	    SELECT
	<# 
	first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	            <# Write(first ? "  " : ", ");#>[<#= primaryKeysRow.COLUMN_NAME #>]
	<# 
	    first = false;
	}   #>
	        INTO #<#= deletedTableName #> 
	        FROM [deleted];
	    
	    DECLARE @InsertºCount   INT;
	    DECLARE @DeleteºCount   INT;
	    
	    SELECT @InsertºCount = COUNT(*) FROM #<#= insertedTableName #>;
	    SELECT @DeleteºCount = COUNT(*) FROM #<#= deletedTableName #>;

	    SET @AuditºAction = 'U';
	    IF @DeleteºCount = 0
	        SET @AuditºAction = 'I';
	    IF @InsertºCount = 0
	        SET @AuditºAction = 'D';

	-- Variables to hold values of primary keys
	<# 
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	    DECLARE @<#= primaryKeysRow.COLUMN_NAME #> <#= SchemaHelper.DataTypeWithDetail(primaryKeysRow, schemaDataSet.Columns) #>;
	<# 
	}   #>

	    IF @InsertºCount > 0
	    BEGIN
	        -- Could be Insert or Update
	        IF @InsertºCount = 1
	        BEGIN
	            SELECT 
	<# 
	first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	                    <# Write(first ? "  " : ", ");#>@<#= primaryKeysRow.COLUMN_NAME #> = [<#= primaryKeysRow.COLUMN_NAME #>]
	<# 
	    first = false;
	}   #>
	                FROM #<#= insertedTableName #>;

	            EXECUTE [<#= _params.AuditingSchema #>].[Trackº<#= _schema #>º<#= _tableName #>] 
	                @AuditºTransactionSequence
	              , @AuditºTransactionDepth
	              , @AuditºAction
	              , @TrackºId OUTPUT
	              , @AuditºTimeStampUtc OUTPUT
	              , @AuditºDesignatedUserId
	<# 
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	              , @<#= primaryKeysRow.COLUMN_NAME #>
	<# 
	}   #>			  ;

	        END  
	        ELSE
	        BEGIN
	            DECLARE insert_cursor CURSOR LOCAL
	                FAST_FORWARD
	                FOR SELECT
	<# 
	first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	                        <# Write(first ? "  " : ", "); #>[<#= primaryKeysRow.COLUMN_NAME #>]
	<#
	    first = false;
	}   #>
	                    FROM #<#= insertedTableName #>;

	            OPEN insert_cursor;
	            
	                FETCH NEXT FROM insert_cursor INTO 
	                    <# 
	first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   
	    Write(first ? "  " : ", "); #>@<# Write(primaryKeysRow.COLUMN_NAME);
	    first = false;
	}   #>;

	                WHILE @@FETCH_STATUS = 0
	                    BEGIN
	                        EXECUTE [<#= _params.AuditingSchema #>].[Trackº<#= _schema #>º<#= _tableName #>] 
	                              @AuditºTransactionSequence
	                            , @AuditºTransactionDepth
	                            , @AuditºAction
	                            , @TrackºId OUTPUT
	                            , @AuditºTimeStampUtc OUTPUT
	                            , @AuditºDesignatedUserId
	<# 
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	                            , @<#= primaryKeysRow.COLUMN_NAME #>
	<#
	}   #>                            ;

	                        FETCH NEXT FROM insert_cursor INTO 
	                            <# 
	first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   
	    Write(first ? "  " : ", "); #>@<# Write(primaryKeysRow.COLUMN_NAME);
	    first = false;
	}   #>;

	                    END;

	            CLOSE insert_cursor;
	        END
	    END
	    ELSE
	    BEGIN
	        -- Can only be Delete
	        IF @DeleteºCount = 1
	        BEGIN
	            SELECT 
	<# 
	first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	                    <# Write(first ? "  " : ", ");#>@<#= primaryKeysRow.COLUMN_NAME #> = [<#= primaryKeysRow.COLUMN_NAME #>]
	<# 
	    first = false;
	}   #>
	                FROM #<#= deletedTableName #>;

	            EXECUTE [<#= _params.AuditingSchema #>].[Trackº<#= _schema #>º<#= _tableName #>] 
	                @AuditºTransactionSequence
	              , @AuditºTransactionDepth
	              , @AuditºAction
	              , @TrackºId OUTPUT
	              , @AuditºTimeStampUtc OUTPUT
	              , @AuditºDesignatedUserId
	<# 
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	              , @<#= primaryKeysRow.COLUMN_NAME #>
	<# 
	}   #>              ;

	        END  
	        ELSE
	        BEGIN
	            DECLARE delete_cursor CURSOR LOCAL
	                FAST_FORWARD
	                FOR SELECT
	<# 
	first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	                        <# Write(first ? "  " : ", "); #>[<#= primaryKeysRow.COLUMN_NAME #>]
	<#
	    first = false;
	}   #>
	                    FROM #<#= deletedTableName #>;

	            OPEN delete_cursor;
	                FETCH NEXT FROM delete_cursor INTO 
	                    <# 
	first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   
	    Write(first ? "  " : ", "); #>@<# Write(primaryKeysRow.COLUMN_NAME);
	    first = false;
	}   #>;

	                WHILE @@FETCH_STATUS = 0
	                    BEGIN
	                        EXECUTE [<#= _params.AuditingSchema #>].[Trackº<#= _schema #>º<#= _tableName #>] 
	                            @AuditºTransactionSequence
	                          , @AuditºTransactionDepth
	                          , @AuditºAction
	                          , @TrackºId OUTPUT
	                          , @AuditºTimeStampUtc OUTPUT
	                          , @AuditºDesignatedUserId
	<# 
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   #>
	                          , @<#= primaryKeysRow.COLUMN_NAME #>
	<#
	}   #>                          ;

	                        FETCH NEXT FROM delete_cursor INTO 
	                            <# 
	first = true;
	foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
	{   
	    Write(first ? "  " : ", "); #>@<# Write(primaryKeysRow.COLUMN_NAME);
	    first = false;
	}   #>;

	                    END;

	            CLOSE delete_cursor;
	        END;
	    END;

	    IF @AuditºIsLocalTransactionSequence <> 0
	    BEGIN
	        EXECUTE [<#= _params.AuditingSchema #>].[ReleaseTransactionSequence] 
	              @AuditºTransactionSequence
	            , @AuditºTransactionDepth;
	    END;
	END TRY
	BEGIN CATCH
	    DECLARE	  @ErrorMessage    NVARCHAR(4000)
			  	, @ErrorNumber     INT
				, @ErrorSeverity   INT
				, @ErrorState      INT
				, @ErrorLine       INT
				, @ErrorProcedure  NVARCHAR(200);

	    -- Assign variables to error-handling functions that 
	    -- capture information for RAISERROR.
	    SELECT	  @ErrorNumber = ERROR_NUMBER()
				, @ErrorSeverity = ERROR_SEVERITY()
				, @ErrorState = ERROR_STATE()
				, @ErrorLine = ERROR_LINE()
				, @ErrorProcedure = ISNULL(ERROR_PROCEDURE(), '-');

	    -- Build the message string that will contain original
	    -- error information.
	    SELECT @ErrorMessage = N'Error %d, Level %d, State %d, Procedure %s, Line %d, Message: '+ ERROR_MESSAGE();
		
		IF @ErrorState = 0
			SET @ErrorState = 1;

	    -- Raise an error: msg_str parameter of RAISERROR will contain
	    -- the original error information.
	    RAISERROR 
	        (
	          @ErrorMessage 
	        , @ErrorSeverity 
	        , 1               
	        , @ErrorNumber    	-- parameter: original error number.
	        , @ErrorSeverity  	-- parameter: original error severity.
	        , @ErrorState     	-- parameter: original error state.
	        , @ErrorProcedure 	-- parameter: original error procedure name.
	        , @ErrorLine       	-- parameter: original error line number.
	        );

	END CATCH;

END
GO
