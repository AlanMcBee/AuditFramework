<#@ template language="C#" #>
<#@ import namespace="System.Data" #>
<#@ import namespace="System.Data.EntityClient" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="CodeCharm.Data.AuditFramework" #>
<#@ import namespace="CodeCharm.Entity.AuditFramework" #>

<# 
string currentVersionTrackIdName = _trackingTable.ToString() + "ºTrackºId";
bool first;

SchemaDataSet schemaDataSet = _params.SchemaDataSet;
SchemaDataSet.SchemaPrimaryKeysDataTable primaryKeysTable = schemaDataSet.SchemaPrimaryKeys;
EnumerableRowCollection<SchemaDataSet.SchemaPrimaryKeysRow> primaryKeysRows = primaryKeysTable.AsEnumerable();
var primaryKeysQuery = from primaryKeysRow in primaryKeysRows
                       where primaryKeysRow.TABLE_SCHEMA.Equals(_schema, StringComparison.OrdinalIgnoreCase)
                       where primaryKeysRow.TABLE_NAME.Equals(_tableName, StringComparison.OrdinalIgnoreCase)
                       select primaryKeysRow;                   

IOrderedQueryable<Catalog> priorVersionTrackingTableQuery = null;
EntityConnectionStringBuilder connectionStringBuilder = Generator.GetEntityConnectionStringBuilder(_params);
AuditFrameworkEntities context = new AuditFrameworkEntities(connectionStringBuilder.ToString());
if (schemaDataSet.SchemaTables.TableExists(_params.AuditingSchema, "Catalog"))
{
    priorVersionTrackingTableQuery = from catalog in context.Catalogs
                                     where catalog.AuditedSchema.Equals(_schema, StringComparison.OrdinalIgnoreCase)
                                     where catalog.AuditedTableName.Equals(_tableName, StringComparison.OrdinalIgnoreCase)
                                     where catalog.Version < _trackingTable.Version
                                     where !catalog.Archived
                                     orderby catalog.Version descending
                                     select catalog;
}                   
#>
IF  EXISTS (SELECT * FROM sys.objects WHERE object_id = OBJECT_ID(N'[<#= _params.AuditingSchema #>].[Deltaº<#= _trackingTable.ToString() #>]') AND type IN (N'P', N'PC'))
    DROP PROCEDURE [<#= _params.AuditingSchema #>].[Deltaº<#= _trackingTable.ToString() #>];
GO

CREATE PROCEDURE [<#= _params.AuditingSchema #>].[Deltaº<#= _trackingTable.ToString() #>]
  @<#= currentVersionTrackIdName #>     [BIGINT]
, @PriorºTrackId    [BIGINT] = NULL OUTPUT
AS

/*
    READ THIS BEFORE EDITING THIS CODE
    ----------------------------------
    This code was automatically generated by the
    CodeCharm.Model.AuditFramework
    project.
    
    If you modify this code, and then execute 
    the AuditFramework tool, your modifications
    will be ignored and overwritten.
    
    Template: CreateUpdateDeltaTableProcedure.tt
    
    REMARKS
    -------
    This procedure is not meant to be called by users or applications
    directly. It is only meant to be called by the BuildDelta procedure.
    
    This procedure creates a Delta record (in the tables with the Δ symbol).
    A Delta record contains a bitmask showing which fields have 
    changed since the last recorded values of the fields.
    
    A Baseline record will show all fields as having not changed (all False).
    An Inserted or Deleted record will show all fields as having changed (all True).
    Only the Updated records will show the evaluated changes for each field.
    
    This procedure must compare the current track record, using the current schema 
    version, against potentially many earlier schema versions. Where the schema
    has mismatched fields (a field exists in one version of the schema 
    but not the other), the missing field is treated as a NULL and compared 
    against the existing field.
*/

	-- Track whether any changes were made at all
	DECLARE @AnyDelta [BIT]
	SET @AnyDelta = 0	

    -- Get the primary keys of this entry
<# 
foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
{   #>
    DECLARE @PKº<#= primaryKeysRow.COLUMN_NAME #> <#= SchemaHelper.DataTypeWithDetail(primaryKeysRow, schemaDataSet.Columns) #>;
<# 
}   #>
    
    SELECT
<# 
first = true;
PushIndent("            ");
foreach(SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
{
    Write(first ? "  " : ", ");
    WriteLine("@PKº" + primaryKeysRow.COLUMN_NAME + " = [" + primaryKeysRow.COLUMN_NAME + "]");
    first = false;
}
PopIndent();
#>
        FROM    [<#= _params.AuditingSchema #>].[<#= _trackingTable.ToString() #>]
        WHERE   [TrackºId] = @<#= currentVersionTrackIdName #>;
        
    DECLARE @CurrentºAction [NCHAR](1);
    SELECT  @CurrentºAction = [Action]
        FROM    [<#= _params.AuditingSchema #>].[AuditMaster]
        WHERE   [TrackºId] = @<#= currentVersionTrackIdName #>;

    IF (@CurrentºAction = 'B')
    BEGIN
		-- New baselines are always set to all zeros
		-- to indicate no changes since previous entry (since there is no previous entry)
        INSERT  [<#= _params.AuditingSchema #>].[<#= _trackingTable.ToString() #>Δ]
            (
              [TrackºId]
<# 
foreach (SchemaDataSet.ColumnsRow targetColumn in _targetTableColumns)
{   #>
            , [<#= targetColumn.COLUMN_NAME #>]
<#
}   #>          
            )
            VALUES
            (
              @<#= currentVersionTrackIdName #>
<# 
foreach (SchemaDataSet.ColumnsRow targetColumn in _targetTableColumns)
{   #>
            , 0
<#
}   #>          
            );
			
		-- Even though we say that no changes happened in any fields,
		-- we always consider a baseline to be a change so that it appears in reports
		SET @AnyDelta = 1; 
    END
    ELSE IF (@CurrentºAction = 'D' OR @CurrentºAction = 'I')
    BEGIN
		-- New Delete and new Insert actions are always set to all ones
		-- to indicate that every field has been set (for inserts) or removed (for deletes)
        INSERT  [<#= _params.AuditingSchema #>].[<#= _trackingTable.ToString() #>Δ]
            (
              [TrackºId]
<# 
foreach (SchemaDataSet.ColumnsRow targetColumn in _targetTableColumns)
{   #>
            , [<#= targetColumn.COLUMN_NAME #>]
<#
}   #>          
            )
            VALUES
            (
              @<#= currentVersionTrackIdName #>
<# 
foreach (SchemaDataSet.ColumnsRow targetColumn in _targetTableColumns)
{   #>
            , 1
<#
}   #>          
            );            
			
		SET @AnyDelta = 1; -- An Insert or Delete is always a change
    END
    ELSE
    BEGIN
        -- Process update action

        -- Find the TrackId of the most recent track/delta record in 
        -- the CURRENT tracking table that matches the primary keys of this entry
    
        SELECT    TOP 1 @PriorºTrackId = [M].[TrackºId]
            FROM    [<#= _params.AuditingSchema #>].[<#= _trackingTable.ToString() #>] AS [T]
                INNER JOIN  [<#= _params.AuditingSchema #>].[AuditMaster] AS [M]
                        ON  [M].[TrackºId] = [T].[TrackºId]
            WHERE   [M].[TrackºId] < @<#= currentVersionTrackIdName #>
<# 
foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
{   #>
                AND [T].[<#= primaryKeysRow.COLUMN_NAME #>] = @PKº<#= primaryKeysRow.COLUMN_NAME #>
<#
}   #>
            ORDER BY    [M].[TrackºId] DESC;

        -- If found, compare fields of that track record to the current track record and create the delta record, then return
        IF (@PriorºTrackId IS NOT NULL)
        BEGIN
            -- Variables to store values for comparison
<# 
foreach (SchemaDataSet.ColumnsRow targetColumn in _targetTableColumns)
{   #>
            DECLARE       @<#= targetColumn.COLUMN_NAME #> <#= SchemaHelper.DataTypeAsVariable(targetColumn) #>;
            DECLARE @Priorº<#= targetColumn.COLUMN_NAME #> <#= SchemaHelper.DataTypeAsVariable(targetColumn) #>;
            DECLARE @Deltaº<#= targetColumn.COLUMN_NAME #> [BIT];
        
<#
}   #>  
    
            -- Get the values of the current record
            SELECT
<# 
first = true;
PushIndent("                ");
foreach(SchemaDataSet.ColumnsRow targetColumn in _targetTableColumns)
{
    Write(first ? "  " : ", ");
    WriteLine("@" + targetColumn.COLUMN_NAME + " = [" + targetColumn.COLUMN_NAME + "]");
    first = false;
}
PopIndent();
#>
                FROM    <#= _trackingTable.ToString() #>
                WHERE   [TrackºId] = @<#= currentVersionTrackIdName #>;

            -- Get Prior values for comparison
            SELECT
<# 
first = true;
PushIndent("                    ");
foreach(SchemaDataSet.ColumnsRow targetColumn in _targetTableColumns)
{
    Write(first ? "  " : ", ");
    WriteLine("@Priorº" + targetColumn.COLUMN_NAME + " = [" + targetColumn.COLUMN_NAME + "]");
    first = false;
}
PopIndent();
#>
                FROM    <#= _trackingTable.ToString() #>
                WHERE   [TrackºId] = @PriorºTrackId;
        
            -- Set Delta bits
<# 
foreach (SchemaDataSet.ColumnsRow targetColumn in _targetTableColumns)
{   #>
            SET @Deltaº<#= targetColumn.COLUMN_NAME #> = CASE WHEN (@<#= targetColumn.COLUMN_NAME #> IS NULL AND @Priorº<#= targetColumn.COLUMN_NAME #> IS NULL) OR (@<#= targetColumn.COLUMN_NAME #> = @Priorº<#= targetColumn.COLUMN_NAME #><#= SchemaHelper.IsStringDataType(targetColumn) ? " COLLATE Latin1_General_BIN" : string.Empty #> ) THEN 0 ELSE 1 END;
			SET @AnyDelta = CONVERT(BIT, CONVERT(INT, @AnyDelta) | CONVERT(INT, @Deltaº<#= targetColumn.COLUMN_NAME #>));

<#
}   #>

            -- Set bits for record with current version schema
            INSERT  [<#= _params.AuditingSchema #>].[<#= _trackingTable.ToString() #>Δ]
                (
                  [TrackºId]
<# foreach(SchemaDataSet.ColumnsRow targetColumn in _targetTableColumns)
{   #>
                , [<#= targetColumn.COLUMN_NAME #>]
<#
}   #>
                )
                VALUES
                (
                  @<#= currentVersionTrackIdName #>               
<# 
foreach (SchemaDataSet.ColumnsRow targetColumn in _targetTableColumns)
{   #>
                , @Deltaº<#= targetColumn.COLUMN_NAME #>
<#
}   #>  
                );
                
        END; -- set bits for record with current version schema
                        
<# 
if (null != priorVersionTrackingTableQuery)
{   #>
        -- Else, set bits for records with earlier version schemas
        -- Go to the next earlier version of the tracking table and repeat above steps    
<#  foreach (Catalog catalog in priorVersionTrackingTableQuery) // begin previous version search
    {   #>
        -- Check against <#= catalog.AuditingTableName #>
        IF (@PriorºTrackId IS NULL)
        BEGIN
			-- A prior track record has not yet been found
			-- Execute earlier delta procedures (will ignore dropped fields and always compare new fields to NULL)
            EXECUTE [<#= _params.AuditingSchema #>].[Deltaº<#= catalog.AuditingTableName #>]
                  @<#= currentVersionTrackIdName #>		-- always compare against the current record      
                , @PriorºTrackId    OUTPUT
				, @AnyDelta			OUTPUT
<#      foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
        {   #>
                , @PKº<#= primaryKeysRow.COLUMN_NAME #>
<#
        }   #>                ;
            
        END;
<#  } // end of previous version search
}
#>          
            
    END; -- process update action

	-- By this point, we might have a PriorTrackId value (not guaranteed)
    -- Set the PriorTrackºId field in the AuditMaster

    IF (@CurrentºAction = 'B' OR @CurrentºAction = 'I')
    BEGIN
        UPDATE  [<#= _params.AuditingSchema #>].[AuditMaster]
            SET   [PriorTrackºId] = @<#= currentVersionTrackIdName #>
				, [AnyDelta] = @AnyDelta
            WHERE   [TrackºId] = @<#= currentVersionTrackIdName #>;            
    END
    ELSE
    BEGIN
<#
if (schemaDataSet.SchemaTables.TableExists(_params.AuditingSchema, "Catalog"))
{   #>
        -- For 'D'elete actions ('U'pdate should already have found a PriorTrackId)
<#
    priorVersionTrackingTableQuery = from catalog in context.Catalogs
                                     where catalog.AuditedSchema.Equals(_schema, StringComparison.OrdinalIgnoreCase)
                                     where catalog.AuditedTableName.Equals(_tableName, StringComparison.OrdinalIgnoreCase)
                                     where !catalog.Archived
                                     orderby catalog.Version descending
                                     select catalog;
    foreach (Catalog catalog in priorVersionTrackingTableQuery)
    {   #>
        IF (@PriorºTrackId IS NULL)
        BEGIN
            SELECT    TOP 1 @PriorºTrackId = [M].[TrackºId]
                FROM    [<#= _params.AuditingSchema #>].[<#= new TrackingTable(catalog.AuditedSchema, catalog.AuditedTableName, catalog.Version).ToString() #>] AS [T]
                    INNER JOIN  [<#= _params.AuditingSchema #>].[AuditMaster] AS [M]
                            ON  [M].[TrackºId] = [T].[TrackºId]
                WHERE   [M].[TrackºId] < @<#= currentVersionTrackIdName #>
<# 
        foreach (SchemaDataSet.SchemaPrimaryKeysRow primaryKeysRow in primaryKeysQuery)
        {   #>
                    AND [T].[<#= primaryKeysRow.COLUMN_NAME #>] = @PKº<#= primaryKeysRow.COLUMN_NAME #>
<#
        }   #>
                ORDER BY    [M].[TrackºId] DESC;

        END
<#
    }   
}   #>

        UPDATE  [<#= _params.AuditingSchema #>].[AuditMaster]
	        SET   [PriorTrackºId] = @PriorºTrackId
				, [AnyDelta] = @AnyDelta
            WHERE   [TrackºId] = @<#= currentVersionTrackIdName #>;
    
    END;

GO
